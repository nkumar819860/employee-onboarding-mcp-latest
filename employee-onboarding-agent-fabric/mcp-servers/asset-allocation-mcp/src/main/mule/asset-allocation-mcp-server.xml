<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns="http://www.mulesoft.org/schema/mule/core" 
      xmlns:db="http://www.mulesoft.org/schema/mule/db" 
      xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
      xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
      xmlns:http="http://www.mulesoft.org/schema/mule/http"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="
        http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
        http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd
        http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
        http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd">

  <!-- âœ… FIXED: Database Initialization (runs ONCE on startup) -->
  <flow name="initialize-mcp-database">
    <scheduler doc:name="Startup Only">
      <scheduling-strategy>
        <fixed-frequency frequency="3000" timeUnit="MILLISECONDS"/>
      </scheduling-strategy>
    </scheduler>
    
    <logger level="INFO" message="ðŸ”§ Initializing Asset Allocation MCP Database..." />
    
    <try>
      <!-- Test PostgreSQL -->
      <db:execute-script config-ref="postgres-config">
        <db:sql><![CDATA[
          -- Load full database schema from init.sql
          CREATE TABLE IF NOT EXISTS departments (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            description VARCHAR(255),
            manager_name VARCHAR(100),
            budget_allocation DECIMAL(12,2),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          CREATE TABLE IF NOT EXISTS employees (
            id SERIAL PRIMARY KEY,
            employee_id VARCHAR(20) UNIQUE NOT NULL,
            first_name VARCHAR(50) NOT NULL,
            last_name VARCHAR(50) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            phone VARCHAR(20),
            department_id INTEGER REFERENCES departments(id),
            position VARCHAR(100),
            hire_date DATE,
            termination_date DATE NULL,
            status VARCHAR(20) DEFAULT 'ACTIVE',
            manager_id INTEGER REFERENCES employees(id),
            location VARCHAR(100),
            cost_center VARCHAR(50),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          CREATE TABLE IF NOT EXISTS asset_categories (
            id SERIAL PRIMARY KEY,
            category_name VARCHAR(50) UNIQUE NOT NULL,
            description VARCHAR(255),
            requires_approval BOOLEAN DEFAULT FALSE,
            max_allocation_per_employee INTEGER DEFAULT 1,
            depreciation_years INTEGER DEFAULT 3,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          CREATE TABLE IF NOT EXISTS assets (
            id SERIAL PRIMARY KEY,
            asset_tag VARCHAR(50) UNIQUE NOT NULL,
            asset_name VARCHAR(100) NOT NULL,
            category_id INTEGER REFERENCES asset_categories(id),
            brand VARCHAR(50),
            model VARCHAR(100),
            serial_number VARCHAR(100) UNIQUE,
            purchase_date DATE,
            purchase_cost DECIMAL(10,2),
            warranty_expiry DATE,
            status VARCHAR(20) DEFAULT 'AVAILABLE',
            condition_status VARCHAR(20) DEFAULT 'NEW',
            location VARCHAR(100),
            vendor VARCHAR(100),
            specifications TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          CREATE TABLE IF NOT EXISTS asset_allocations (
            id SERIAL PRIMARY KEY,
            asset_id INTEGER REFERENCES assets(id),
            employee_id INTEGER REFERENCES employees(id),
            allocated_date DATE DEFAULT CURRENT_DATE,
            expected_return_date DATE,
            actual_return_date DATE NULL,
            allocation_status VARCHAR(20) DEFAULT 'ALLOCATED',
            allocation_reason VARCHAR(255),
            approved_by VARCHAR(100),
            approval_date DATE,
            return_condition VARCHAR(20),
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
          
          DO $$ BEGIN
            IF NOT EXISTS (SELECT 1 FROM departments WHERE name = '_INIT_COMPLETE_') THEN
              INSERT INTO departments (name) VALUES ('IT'), ('HR'), ('Engineering');
              INSERT INTO departments (name) VALUES ('_INIT_COMPLETE_');
            END IF;
          END $$;
        ]]></db:sql>
      </db:execute-script>
      
      <set-variable variableName="activeDatabase" value="'postgres'" />
      <logger level="INFO" message="âœ… PostgreSQL initialized successfully" />
      
      <error-handler>
        <on-error-continue type="DB:CONNECTIVITY">
          <logger level="WARN" message="âš ï¸ PostgreSQL unavailable, initializing H2..." />
          
          <db:execute-script config-ref="h2-config">
            <db:sql><![CDATA[
              CREATE TABLE IF NOT EXISTS departments (
                id IDENTITY PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
              );
              
              MERGE INTO departments (name) KEY(name) VALUES ('IT');
              MERGE INTO departments (name) KEY(name) VALUES ('HR');  
              MERGE INTO departments (name) KEY(name) VALUES ('Engineering');
              MERGE INTO departments (name) KEY(name) VALUES ('_INIT_COMPLETE_');
            ]]></db:sql>
          </db:execute-script>
          
          <set-variable variableName="activeDatabase" value="'h2'" />
          <logger level="INFO" message="âœ… H2 database initialized successfully" />
        </on-error-continue>
      </error-handler>
    </try>
  </flow>

  <!-- âœ… Health Check -->
  <flow name="health-check">
    <http:listener config-ref="http-config" path="/health" />
    <set-payload value="#[output application/json --- {
      status: 'UP',
      service: 'Asset Allocation MCP Server v1.0.0',
      database: vars.activeDatabase default 'uninitialized',
      timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
      javaVersion: '17'
    }]" />
    <logger level="INFO" message="Health check OK" />
  </flow>

  <!-- âœ… MCP Server Info -->
  <flow name="mcp-info">
    <http:listener config-ref="http-config" path="/mcp/info" />
    <set-payload value="#[output application/json --- {
      name: 'Asset Allocation MCP Server',
      version: '1.0.0',
      description: 'Manages IT asset allocation (laptops, ID cards, etc)',
      javaVersion: '17',
      endpoints: [
        {name: 'allocate-assets', path: '/mcp/tools/allocate-assets'},
        {name: 'return-asset', path: '/mcp/tools/return-asset'},
        {name: 'list-assets', path: '/mcp/tools/list-assets'},
        {name: 'get-available-assets', path: '/mcp/tools/get-available-assets'},
        {name: 'get-employee-assets', path: '/mcp/tools/get-employee-assets'}
      ],
      database: vars.activeDatabase default 'uninitialized'
    }]" />
  </flow>

  <!-- âœ… NEW: Allocate Assets (Main MCP Tool) -->
  <flow name="allocate-assets">
    <http:listener config-ref="http-config" path="/mcp/tools/allocate-assets" />
    
    <logger level="INFO" message="Asset allocation request for employee: #[payload.employeeId]" />
    <set-variable variableName="requestPayload" value="#[payload]" />
    <set-variable variableName="allocatedAssets" value="#[[]]" />
    
    <try>
      <!-- Get employee info -->
      <choice>
        <when expression="#[vars.activeDatabase == 'postgres']">
          <db:select config-ref="postgres-config">
            <db:sql><![CDATA[
              SELECT e.*, d.name as department_name 
              FROM employees e 
              LEFT JOIN departments d ON e.department_id = d.id 
              WHERE e.employee_id = :employeeId AND e.status = 'ACTIVE'
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{'employeeId': vars.requestPayload.employeeId}]]]></db:input-parameters>
          </db:select>
        </when>
        <otherwise>
          <set-payload value="#[[{employee_id: vars.requestPayload.employeeId, first_name: vars.requestPayload.firstName, last_name: vars.requestPayload.lastName, department_name: vars.requestPayload.department}]]" />
        </otherwise>
      </choice>
      
      <choice>
        <when expression="#[payload.size() > 0]">
          <set-variable variableName="employeeInfo" value="#[payload[0]]" />
          
          <!-- Smart asset allocation based on requested assets or defaults -->
          <set-variable variableName="assetsToAllocate" value="#[vars.requestPayload.assets default ['laptop', 'id-card']]" />
          
          <!-- Allocate each requested asset -->
          <foreach collection="#[vars.assetsToAllocate]">
            <set-variable variableName="currentAssetType" value="#[payload]" />
            
            <!-- Find available asset of this type -->
            <choice>
              <when expression="#[vars.activeDatabase == 'postgres']">
                <db:select config-ref="postgres-config">
                  <db:sql><![CDATA[
                    SELECT a.*, ac.category_name 
                    FROM assets a 
                    JOIN asset_categories ac ON a.category_id = ac.id 
                    WHERE UPPER(ac.category_name) = UPPER(:assetType) 
                    AND a.status = 'AVAILABLE' 
                    ORDER BY a.purchase_date DESC 
                    LIMIT 1
                  ]]></db:sql>
                  <db:input-parameters><![CDATA[#[{'assetType': vars.currentAssetType}]]]></db:input-parameters>
                </db:select>
              </when>
              <otherwise>
                <!-- Mock data for H2/demo -->
                <set-payload value="#[[{
                  id: 1,
                  asset_tag: 'DEMO-' ++ vars.currentAssetType as String ++ '-001',
                  asset_name: vars.currentAssetType as String ++ ' (Demo Asset)',
                  category_name: vars.currentAssetType,
                  brand: 'Demo Brand',
                  model: 'Demo Model',
                  serial_number: 'DEMO123456',
                  condition_status: 'NEW'
                }]]" />
              </otherwise>
            </choice>
            
            <choice>
              <when expression="#[payload.size() > 0]">
                <set-variable variableName="selectedAsset" value="#[payload[0]]" />
                
                <!-- Create allocation record -->
                <choice>
                  <when expression="#[vars.activeDatabase == 'postgres']">
                    <!-- Update asset status -->
                    <db:update config-ref="postgres-config">
                      <db:sql><![CDATA[
                        UPDATE assets 
                        SET status = 'ALLOCATED', updated_at = CURRENT_TIMESTAMP 
                        WHERE id = :assetId
                      ]]></db:sql>
                      <db:input-parameters><![CDATA[#[{'assetId': vars.selectedAsset.id}]]]></db:input-parameters>
                    </db:update>
                    
                    <!-- Create allocation record -->
                    <db:insert config-ref="postgres-config">
                      <db:sql><![CDATA[
                        INSERT INTO asset_allocations 
                        (asset_id, employee_id, allocated_date, allocation_status, allocation_reason, approved_by, approval_date, notes)
                        VALUES (:assetId, 
                               (SELECT id FROM employees WHERE employee_id = :employeeId), 
                               CURRENT_DATE, 'ALLOCATED', 'Employee Onboarding', 'MCP System', CURRENT_DATE,
                               'Allocated via Asset Allocation MCP Server')
                      ]]></db:sql>
                      <db:input-parameters><![CDATA[#[{
                        'assetId': vars.selectedAsset.id,
                        'employeeId': vars.requestPayload.employeeId
                      }]]]></db:input-parameters>
                    </db:insert>
                  </when>
                </choice>
                
                <!-- Add to allocated assets list -->
                <set-variable variableName="allocatedAssets" value="#[vars.allocatedAssets + [{
                  assetId: vars.selectedAsset.id,
                  assetTag: vars.selectedAsset.asset_tag,
                  assetName: vars.selectedAsset.asset_name,
                  category: vars.selectedAsset.category_name,
                  brand: vars.selectedAsset.brand,
                  model: vars.selectedAsset.model,
                  serialNumber: vars.selectedAsset.serial_number,
                  condition: vars.selectedAsset.condition_status,
                  allocationDate: now() as String {format: 'yyyy-MM-dd'},
                  status: 'ALLOCATED'
                }]]" />
                
                <logger level="INFO" message="Asset allocated: #[vars.selectedAsset.asset_tag] to #[vars.requestPayload.employeeId]" />
              </when>
              <otherwise>
                <logger level="WARN" message="No available asset of type: #[vars.currentAssetType]" />
              </otherwise>
            </choice>
          </foreach>
          
          <!-- Return success response -->
          <set-payload value="#[output application/json --- {
            status: 'success',
            message: 'Assets allocated successfully',
            employeeId: vars.requestPayload.employeeId,
            employeeName: vars.employeeInfo.first_name ++ ' ' ++ vars.employeeInfo.last_name,
            allocatedAssets: vars.allocatedAssets,
            allocationCount: sizeOf(vars.allocatedAssets),
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
        </when>
        <otherwise>
          <set-payload value="#[output application/json --- {
            status: 'error',
            message: 'Employee not found or inactive',
            employeeId: vars.requestPayload.employeeId,
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
        </otherwise>
      </choice>
      
      <error-handler>
        <on-error-propagate type="ANY">
          <set-payload value="#[output application/json --- {
            status: 'error',
            message: 'Asset allocation failed',
            error: error.description,
            employeeId: vars.requestPayload.employeeId default 'unknown',
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
          <logger level="ERROR" message="Asset allocation error: #[error.description]" />
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- âœ… NEW: Get Available Assets -->
  <flow name="get-available-assets">
    <http:listener config-ref="http-config" path="/mcp/tools/get-available-assets" />
    
    <logger level="INFO" message="Getting available assets" />
    
    <try>
      <choice>
        <when expression="#[vars.activeDatabase == 'postgres']">
          <db:select config-ref="postgres-config">
            <db:sql><![CDATA[
              SELECT a.*, ac.category_name 
              FROM assets a 
              JOIN asset_categories ac ON a.category_id = ac.id 
              WHERE a.status = 'AVAILABLE'
              ORDER BY ac.category_name, a.asset_name
            ]]></db:sql>
          </db:select>
        </when>
        <otherwise>
          <!-- Demo data for H2 -->
          <set-payload value="#[[
            {id: 1, asset_tag: 'LAP-001', asset_name: 'Dell Latitude 7420', category_name: 'LAPTOP', brand: 'Dell', model: 'Latitude 7420', status: 'AVAILABLE'},
            {id: 2, asset_tag: 'ID-001', asset_name: 'Employee ID Card', category_name: 'ID_CARD', brand: 'HID Global', model: 'ProxCard II', status: 'AVAILABLE'},
            {id: 3, asset_tag: 'PHN-001', asset_name: 'iPhone 15 Pro', category_name: 'MOBILE_PHONE', brand: 'Apple', model: 'iPhone 15 Pro', status: 'AVAILABLE'}
          ]]" />
        </otherwise>
      </choice>
      
      <set-payload value="#[output application/json --- {
        status: 'success',
        message: 'Available assets retrieved',
        assets: payload,
        assetCount: sizeOf(payload),
        timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
      }]" />
      
      <error-handler>
        <on-error-propagate type="ANY">
          <set-payload value="#[output application/json --- {
            status: 'error',
            message: 'Failed to retrieve available assets',
            error: error.description,
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
          <logger level="ERROR" message="Get available assets error: #[error.description]" />
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- âœ… NEW: Get Employee Assets -->
  <flow name="get-employee-assets">
    <http:listener config-ref="http-config" path="/mcp/tools/get-employee-assets" />
    
    <logger level="INFO" message="Getting assets for employee: #[payload.employeeId]" />
    <set-variable variableName="employeeId" value="#[payload.employeeId]" />
    
    <try>
      <choice>
        <when expression="#[vars.activeDatabase == 'postgres']">
          <db:select config-ref="postgres-config">
            <db:sql><![CDATA[
              SELECT a.*, ac.category_name, aa.allocated_date, aa.allocation_status, aa.notes
              FROM asset_allocations aa
              JOIN assets a ON aa.asset_id = a.id
              JOIN asset_categories ac ON a.category_id = ac.id
              JOIN employees e ON aa.employee_id = e.id
              WHERE e.employee_id = :employeeId 
              AND aa.allocation_status = 'ALLOCATED'
              ORDER BY aa.allocated_date DESC
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{'employeeId': vars.employeeId}]]]></db:input-parameters>
          </db:select>
        </when>
        <otherwise>
          <!-- Demo data -->
          <set-payload value="#[[
            {asset_tag: 'DEMO-LAP-001', asset_name: 'Demo Laptop', category_name: 'LAPTOP', allocated_date: '2024-01-15', allocation_status: 'ALLOCATED'},
            {asset_tag: 'DEMO-ID-001', asset_name: 'Demo ID Card', category_name: 'ID_CARD', allocated_date: '2024-01-15', allocation_status: 'ALLOCATED'}
          ]]" />
        </otherwise>
      </choice>
      
      <set-payload value="#[output application/json --- {
        status: 'success',
        message: 'Employee assets retrieved',
        employeeId: vars.employeeId,
        assets: payload,
        assetCount: sizeOf(payload),
        timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
      }]" />
      
      <error-handler>
        <on-error-propagate type="ANY">
          <set-payload value="#[output application/json --- {
            status: 'error',
            message: 'Failed to retrieve employee assets',
            error: error.description,
            employeeId: vars.employeeId default 'unknown',
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
          <logger level="ERROR" message="Get employee assets error: #[error.description]" />
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- âœ… NEW: Return Asset -->
  <flow name="return-asset">
    <http:listener config-ref="http-config" path="/mcp/tools/return-asset" />
    
    <logger level="INFO" message="Asset return request for: #[payload.assetTag]" />
    <set-variable variableName="requestPayload" value="#[payload]" />
    
    <try>
      <choice>
        <when expression="#[vars.activeDatabase == 'postgres']">
          <!-- Update asset status to available -->
          <db:update config-ref="postgres-config">
            <db:sql><![CDATA[
              UPDATE assets 
              SET status = 'AVAILABLE', updated_at = CURRENT_TIMESTAMP 
              WHERE asset_tag = :assetTag
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{'assetTag': vars.requestPayload.assetTag}]]]></db:input-parameters>
          </db:update>
          
          <!-- Update allocation record -->
          <db:update config-ref="postgres-config">
            <db:sql><![CDATA[
              UPDATE asset_allocations 
              SET allocation_status = 'RETURNED', 
                  actual_return_date = CURRENT_DATE,
                  return_condition = :condition,
                  notes = COALESCE(notes, '') || ' | Returned: ' || :returnNotes
              WHERE asset_id = (SELECT id FROM assets WHERE asset_tag = :assetTag)
              AND allocation_status = 'ALLOCATED'
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{
              'assetTag': vars.requestPayload.assetTag,
              'condition': vars.requestPayload.condition default 'GOOD',
              'returnNotes': vars.requestPayload.notes default 'Asset returned via MCP'
            }]]]></db:input-parameters>
          </db:update>
        </when>
      </choice>
      
      <set-payload value="#[output application/json --- {
        status: 'success',
        message: 'Asset returned successfully',
        assetTag: vars.requestPayload.assetTag,
        condition: vars.requestPayload.condition default 'GOOD',
        returnDate: now() as String {format: 'yyyy-MM-dd'},
        timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
      }]" />
      
      <error-handler>
        <on-error-propagate type="ANY">
          <set-payload value="#[output application/json --- {
            status: 'error',
            message: 'Asset return failed',
            error: error.description,
            assetTag: vars.requestPayload.assetTag default 'unknown',
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
          <logger level="ERROR" message="Asset return error: #[error.description]" />
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- âœ… List Assets (Enhanced) -->
  <flow name="list-assets">
    <http:listener config-ref="http-config" path="/mcp/tools/list-assets" />
    
    <try>
      <choice>
        <when expression="#[vars.activeDatabase == 'postgres']">
          <db:select config-ref="postgres-config">
            <db:sql><![CDATA[
              SELECT a.*, ac.category_name,
                     CASE WHEN aa.allocation_status = 'ALLOCATED' THEN e.employee_id ELSE NULL END as allocated_to
              FROM assets a 
              JOIN asset_categories ac ON a.category_id = ac.id
              LEFT JOIN asset_allocations aa ON a.id = aa.asset_id AND aa.allocation_status = 'ALLOCATED'
              LEFT JOIN employees e ON aa.employee_id = e.id
              ORDER BY ac.category_name, a.asset_name
            ]]></db:sql>
          </db:select>
        </when>
        <otherwise>
          <set-payload value="#[[
            {asset_tag: 'DEMO-LAP-001', asset_name: 'Demo Laptop', category_name: 'LAPTOP', status: 'AVAILABLE', allocated_to: null},
            {asset_tag: 'DEMO-ID-001', asset_name: 'Demo ID Card', category_name: 'ID_CARD', status: 'ALLOCATED', allocated_to: 'EMP001'}
          ]]" />
        </otherwise>
      </choice>
      
      <set-payload value="#[output application/json --- {
        status: 'success',
        database: vars.activeDatabase default 'unknown',
        assets: payload,
        assetCount: sizeOf(payload),
        timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
      }]" />
      
      <error-handler>
        <on-error-propagate type="ANY">
          <set-payload value="#[output application/json --- {
            status: 'error',
            message: 'Failed to list assets',
            error: error.description,
            timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'}
          }]" />
          <logger level="ERROR" message="List assets error: #[error.description]" />
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

</mule>
