<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:apikit="http://www.mulesoft.org/schema/mule/mule-apikit"
	xmlns:db="http://www.mulesoft.org/schema/mule/db"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
	xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
      http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd
      http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
      http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
      http://www.mulesoft.org/schema/mule/mule-apikit http://www.mulesoft.org/schema/mule/mule-apikit/current/mule-apikit.xsd">

	<!-- ========================================================================================= -->
	<!-- APIKIT ROUTER - MODERN API GATEWAY WITH AUTOMATIC ROUTING -->
	<!-- ========================================================================================= -->

	<flow name="asset-allocation-mcp-api-main" doc:name="APIKit Main Router">
		<http:listener config-ref="HTTP_Listener_config" path="/api/*" doc:name="API Listener">
			<http:response statusCode="#[vars.httpStatus default 200]">
				<http:headers>#[vars.outboundHeaders default {}]</http:headers>
			</http:response>
			<http:error-response statusCode="#[vars.httpStatus default 500]">
				<http:body><![CDATA[#[payload]]]></http:body>
				<http:headers>#[vars.outboundHeaders default {}]</http:headers>
			</http:error-response>
		</http:listener>
		<apikit:router config-ref="asset-allocation-mcp-api-config" doc:name="APIKit Router"/>
		<error-handler>
			<on-error-propagate type="APIKIT:BAD_REQUEST">
				<ee:transform doc:name="Transform Message">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Bad request"}]]></ee:set-payload>
					</ee:message>
					<ee:variables>
						<ee:set-variable variableName="httpStatus">400</ee:set-variable>
					</ee:variables>
				</ee:transform>
			</on-error-propagate>
			<on-error-propagate type="APIKIT:NOT_FOUND">
				<ee:transform doc:name="Transform Message">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Resource not found"}]]></ee:set-payload>
					</ee:message>
					<ee:variables>
						<ee:set-variable variableName="httpStatus">404</ee:set-variable>
					</ee:variables>
				</ee:transform>
			</on-error-propagate>
			<on-error-propagate type="APIKIT:METHOD_NOT_ALLOWED">
				<ee:transform doc:name="Transform Message">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Method not allowed"}]]></ee:set-payload>
					</ee:message>
					<ee:variables>
						<ee:set-variable variableName="httpStatus">405</ee:set-variable>
					</ee:variables>
				</ee:transform>
			</on-error-propagate>
			<on-error-propagate type="APIKIT:NOT_ACCEPTABLE">
				<ee:transform doc:name="Transform Message">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Not acceptable"}]]></ee:set-payload>
					</ee:message>
					<ee:variables>
						<ee:set-variable variableName="httpStatus">406</ee:set-variable>
					</ee:variables>
				</ee:transform>
			</on-error-propagate>
			<on-error-propagate type="APIKIT:UNSUPPORTED_MEDIA_TYPE">
				<ee:transform doc:name="Transform Message">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Unsupported media type"}]]></ee:set-payload>
					</ee:message>
					<ee:variables>
						<ee:set-variable variableName="httpStatus">415</ee:set-variable>
					</ee:variables>
				</ee:transform>
			</on-error-propagate>
			<on-error-propagate type="APIKIT:NOT_IMPLEMENTED">
				<ee:transform doc:name="Transform Message">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Not Implemented"}]]></ee:set-payload>
					</ee:message>
					<ee:variables>
						<ee:set-variable variableName="httpStatus">501</ee:set-variable>
					</ee:variables>
				</ee:transform>
			</on-error-propagate>
		</error-handler>
	</flow>

	<!-- APIKit Console Flow -->
	<flow name="asset-allocation-mcp-api-console" doc:name="APIKit Console">
		<http:listener config-ref="HTTP_Listener_config" path="/console/*" doc:name="Console Listener">
			<http:response statusCode="200"/>
			<http:error-response statusCode="500">
				<http:body><![CDATA[#[payload]]]></http:body>
			</http:error-response>
		</http:listener>
		<apikit:console config-ref="asset-allocation-mcp-api-config" doc:name="APIKit Console"/>
	</flow>

	<!-- ========================================================================================= -->
	<!-- APIKIT FLOW IMPLEMENTATIONS - AUTOMATIC ROUTING TO BUSINESS LOGIC -->
	<!-- ========================================================================================= -->

	<!-- Health Check Flow -->
	<flow name="get:\health:asset-allocation-mcp-api-config" doc:name="Health Check Implementation">
		<flow-ref name="health-check-implementation" doc:name="Health Check Logic"/>
	</flow>

	<!-- MCP Server Info Flow -->
	<flow name="get:\mcp\info:asset-allocation-mcp-api-config" doc:name="MCP Server Info Implementation">
		<flow-ref name="mcp-server-info-implementation" doc:name="Server Info Logic"/>
	</flow>

	<!-- Asset Allocation Tool Flow -->
	<flow name="post:\mcp\tools\allocate-assets:application\json:asset-allocation-mcp-api-config" doc:name="Allocate Assets Implementation">
		<logger level="INFO" message="APIKit: Allocate assets - Request: #[payload]" doc:name="Log Request"/>
		<flow-ref name="allocate-assets-with-fallback" doc:name="Allocate Assets Logic"/>
	</flow>

	<!-- Return Asset Tool Flow -->
	<flow name="post:\mcp\tools\return-asset:application\json:asset-allocation-mcp-api-config" doc:name="Return Asset Implementation">
		<logger level="INFO" message="APIKit: Return asset - Request: #[payload]" doc:name="Log Request"/>
		<flow-ref name="return-asset-with-fallback" doc:name="Return Asset Logic"/>
	</flow>

	<!-- List Assets Tool Flow -->
	<flow name="get:\mcp\tools\list-assets:asset-allocation-mcp-api-config" doc:name="List Assets Implementation">
		<set-variable variableName="statusFilter" value="#[attributes.queryParams.status default '']" doc:name="Set Status Filter"/>
		<set-variable variableName="categoryFilter" value="#[attributes.queryParams.category default '']" doc:name="Set Category Filter"/>
		<logger level="INFO" message="APIKit: List assets - Status: #[vars.statusFilter], Category: #[vars.categoryFilter]" doc:name="Log Request"/>
		<flow-ref name="list-assets-with-fallback" doc:name="List Assets Logic"/>
	</flow>

	<!-- Get Available Assets Tool Flow -->
	<flow name="get:\mcp\tools\get-available-assets:asset-allocation-mcp-api-config" doc:name="Get Available Assets Implementation">
		<logger level="INFO" message="APIKit: Get available assets" doc:name="Log Request"/>
		<flow-ref name="get-available-assets-with-fallback" doc:name="Get Available Assets Logic"/>
	</flow>

	<!-- Get Employee Assets Tool Flow -->
	<flow name="post:\mcp\tools\get-employee-assets:application\json:asset-allocation-mcp-api-config" doc:name="Get Employee Assets Implementation">
		<set-variable variableName="employeeId" value="#[payload.employeeId]" doc:name="Set Employee ID"/>
		<logger level="INFO" message="APIKit: Get employee assets - ID: #[vars.employeeId]" doc:name="Log Request"/>
		<flow-ref name="get-employee-assets-with-fallback" doc:name="Get Employee Assets Logic"/>
	</flow>

	<!-- ========================================================================================= -->
	<!-- DATABASE INITIALIZATION & HEALTH MANAGEMENT - PRODUCTION READY -->
	<!-- ========================================================================================= -->

	<flow name="database-initialization" initialState="started" doc:name="Smart Database Initialization">
		<scheduler doc:name="Database Init Scheduler">
			<scheduling-strategy>
				<fixed-frequency frequency="300" startDelay="5" timeUnit="SECONDS"/>
			</scheduling-strategy>
		</scheduler>
		
		<choice doc:name="Database Initialization Enabled?">
			<when expression="${db.initialization.enabled}">
				<flow-ref name="smart-database-setup" doc:name="Initialize Database"/>
			</when>
			<otherwise>
				<logger level="DEBUG" message="Database initialization disabled via configuration"/>
			</otherwise>
		</choice>
		
		<!-- Run only once then disable -->
		<set-variable variableName="initComplete" value="true"/>
	</flow>

	<!-- Smart Database Setup with Fallback Strategy -->
	<flow name="smart-database-setup" doc:name="Smart Database Setup">
		<logger level="INFO" message="Starting intelligent database initialization - Strategy: ${db.strategy}"/>
		
		<try doc:name="Primary Database Setup">
			<choice doc:name="Database Strategy Selection">
				<when expression='#["${db.strategy}" == "postgresql"]'>
					<flow-ref name="setup-postgresql-database"/>
					<set-variable variableName="activeDatabase" value="postgresql"/>
				</when>
				<when expression='#["${db.strategy}" == "h2"]'>
					<flow-ref name="setup-h2-database"/>
					<set-variable variableName="activeDatabase" value="h2"/>
				</when>
				<otherwise>
					<!-- Auto-detection: Try PostgreSQL first -->
					<flow-ref name="detect-and-setup-database"/>
				</otherwise>
			</choice>
			
			<logger level="INFO" message="Database initialization completed successfully with: #[vars.activeDatabase]"/>
			
			<error-handler>
				<on-error-continue type="ANY">
					<logger level="ERROR" message="All database initialization failed - switching to mock mode: #[error.description]"/>
					<set-variable variableName="activeDatabase" value="mock"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- Auto-Detection Flow (moved out to avoid nested error handlers) -->
	<flow name="detect-and-setup-database" doc:name="Detect and Setup Database">
		<try doc:name="Try PostgreSQL First">
			<flow-ref name="setup-postgresql-database"/>
			<set-variable variableName="activeDatabase" value="postgresql"/>
			<logger level="INFO" message="Auto-detection successful: Using PostgreSQL"/>
			<error-handler>
				<on-error-continue type="ANY">
					<logger level="WARN" message="PostgreSQL unavailable, falling back to H2: #[error.description]"/>
					<flow-ref name="setup-h2-database"/>
					<set-variable variableName="activeDatabase" value="h2"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- ========================================================================================= -->
	<!-- BUSINESS LOGIC IMPLEMENTATIONS - UPDATED FOR APIKIT -->
	<!-- ========================================================================================= -->

	<!-- Health Check Implementation -->
	<flow name="health-check-implementation" doc:name="Production Health Check">
		<parallel-foreach doc:name="Parallel Health Checks">
			<ee:transform doc:name="Health Check Tasks">
				<ee:message>
					<ee:set-payload><![CDATA[%dw 2.0
output application/java
---
["database", "application", "configuration"]]]></ee:set-payload>
				</ee:message>
			</ee:transform>
			
			<choice doc:name="Health Check Type">
				<when expression='#[payload == "database"]'>
					<flow-ref name="database-health-status"/>
				</when>
				<when expression='#[payload == "application"]'>
					<flow-ref name="application-health-status"/>
				</when>
				<when expression='#[payload == "configuration"]'>
					<flow-ref name="configuration-health-status"/>
				</when>
			</choice>
		</parallel-foreach>
		
		<ee:transform doc:name="Aggregate Health Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	status: if (payload filter ($.healthy == false) != []) "DEGRADED" else "HEALTHY",
	service: "${mcp.server.name}",
	version: "${mcp.server.version}",
	timestamp: now(),
	environment: "${env}",
	checks: payload,
	uptime: (now() - |2024-01-01T00:00:00|) as Number {unit: "seconds"},
	features: {
		mockMode: "${mcp.features.mock.enabled}",
		databaseRequired: "${mcp.features.database.required}",
		auditEnabled: "${mcp.features.audit.enabled}"
	}
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
		
		<logger level="INFO" message="Health check completed - Status: #[payload.status]"/>
	</flow>

	<!-- MCP Server Info Implementation -->
	<flow name="mcp-server-info-implementation" doc:name="MCP Server Discovery">
		<ee:transform doc:name="Server Metadata Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	name: "${mcp.server.name}",
	version: "${mcp.server.version}",
	description: "${mcp.server.description}",
	baseUrl: "${mcp.server.baseUrl}",
	environment: "${env}",
	capabilities: {
		databases: ["postgresql", "h2"],
		fallbackMode: "mock",
		multiTenant: false,
		audit: "${mcp.features.audit.enabled}",
		cache: "${cache.enabled}"
	},
	endpoints: {
		health: "/api/health",
		info: "/api/mcp/info",
		tools: "/api/mcp/tools",
		console: "/console"
	},
	tools: [
		{
			name: "allocate-assets",
			description: "Allocate assets to employees",
			endpoint: "/api/mcp/tools/allocate-assets",
			method: "POST",
			inputSchema: {
				employeeId: "string",
				assets: "array?",
				firstName: "string?",
				lastName: "string?",
				department: "string?",
				position: "string?"
			}
		},
		{
			name: "return-asset",
			description: "Return allocated assets",
			endpoint: "/api/mcp/tools/return-asset",
			method: "POST",
			inputSchema: {
				assetTag: "string",
				condition: "string?",
				notes: "string?"
			}
		},
		{
			name: "list-assets",
			description: "List all assets with status",
			endpoint: "/api/mcp/tools/list-assets",
			method: "GET",
			parameters: ["status?", "category?"]
		},
		{
			name: "get-available-assets",
			description: "Get available assets for allocation",
			endpoint: "/api/mcp/tools/get-available-assets",
			method: "GET"
		},
		{
			name: "get-employee-assets",
			description: "Get assets allocated to specific employee",
			endpoint: "/api/mcp/tools/get-employee-assets",
			method: "POST",
			inputSchema: {
				employeeId: "string"
			}
		}
	]
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
		
		<logger level="INFO" message="MCP server info requested - responding with metadata"/>
	</flow>

	<!-- ========================================================================================= -->
	<!-- CORE BUSINESS LOGIC WITH INTELLIGENT DATABASE FALLBACK -->
	<!-- ========================================================================================= -->

	<!-- Allocate Assets with Fallback Strategy -->
	<flow name="allocate-assets-with-fallback" doc:name="Allocate Assets with Smart Fallback">
		<try doc:name="Database Operation with Fallback">
		<ee:transform doc:name="Validate and Transform Input">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
	employeeId: payload.employeeId default "UNKNOWN",
	firstName: payload.firstName default "",
	lastName: payload.lastName default "",
	department: payload.department default "IT",
	position: payload.position default "Employee",
	assets: if (payload.assets != null and payload.assets is Array) payload.assets else ["laptop", "id-card"]
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
			
			<!-- Try Primary Database First -->
			<try doc:name="Primary Database Operation">
				<choice doc:name="Database Strategy">
					<when expression='#["${db.strategy}" == "h2" or "${env}" == "sandbox" or "${env}" == "production"]'>
						<flow-ref name="allocate-assets-h2"/>
						<set-variable variableName="databaseUsed" value="h2"/>
					</when>
					<otherwise>
						<flow-ref name="allocate-assets-postgresql"/>
						<set-variable variableName="databaseUsed" value="postgresql"/>
					</otherwise>
				</choice>
				
				<error-handler>
					<on-error-continue type="DB:*" doc:name="Fallback to Alternative DB">
						<logger level="WARN" message="Primary database failed, trying fallback database: #[error.description]"/>
						
						<choice doc:name="Try Fallback Database">
							<when expression='#[vars.databaseUsed != "h2"]'>
								<flow-ref name="allocate-assets-h2"/>
								<set-variable variableName="databaseUsed" value="h2-fallback"/>
							</when>
							<otherwise>
								<flow-ref name="allocate-assets-postgresql"/>
								<set-variable variableName="databaseUsed" value="postgresql-fallback"/>
							</otherwise>
						</choice>
						
					</on-error-continue>
				</error-handler>
			</try>
			
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="allocate-assets-mock-response"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- PostgreSQL Asset Allocation -->
	<flow name="allocate-assets-postgresql" doc:name="PostgreSQL Asset Allocation">
		<logger level="INFO" message="ğŸ˜ Processing allocation via PostgreSQL..." />
		<set-variable variableName="allocatedAssets" value="#[[]]" />
		
		<!-- Get or create employee record -->
		<db:select config-ref="PostgreSQL_Database_Config">
			<db:sql><![CDATA[
				SELECT e.*, d.name as department_name 
				FROM employees e 
				LEFT JOIN departments d ON e.department_id = d.id 
				WHERE e.employee_id = :employeeId AND e.status = 'ACTIVE'
			]]></db:sql>
			<db:input-parameters><![CDATA[#[{'employeeId': payload.employeeId}]]]></db:input-parameters>
		</db:select>
		
		<choice>
			<when expression="#[payload.size() > 0]">
				<set-variable variableName="employeeInfo" value="#[payload[0]]" />
			</when>
			<otherwise>
				<!-- Create employee if not exists -->
				<db:insert config-ref="PostgreSQL_Database_Config">
					<db:sql><![CDATA[
						INSERT INTO employees (employee_id, first_name, last_name, email, department_id, position, status) 
						VALUES (:employeeId, :firstName, :lastName, :email, 1, :position, 'ACTIVE')
					]]></db:sql>
					<db:input-parameters><![CDATA[#[{
						'employeeId': payload.employeeId,
						'firstName': payload.firstName,
						'lastName': payload.lastName,
						'email': payload.employeeId ++ '@company.com',
						'position': payload.position
					}]]]></db:input-parameters>
				</db:insert>
			</otherwise>
		</choice>
		
		<!-- Allocate each requested asset -->
		<choice doc:name="Check if assets exist">
			<when expression="#[payload.assets != null and sizeOf(payload.assets) > 0]">
				<foreach collection="#[payload.assets]">
			<set-variable variableName="currentAssetType" value="#[payload]" />
			
			<!-- Find available asset -->
			<db:select config-ref="PostgreSQL_Database_Config">
				<db:sql><![CDATA[
					SELECT a.*, ac.category_name 
					FROM assets a 
					JOIN asset_categories ac ON a.category_id = ac.id 
					WHERE UPPER(ac.category_name) = UPPER(:assetType) 
					AND a.status = 'AVAILABLE' 
					ORDER BY a.purchase_date DESC 
					LIMIT 1
				]]></db:sql>
				<db:input-parameters><![CDATA[#[{'assetType': vars.currentAssetType}]]]></db:input-parameters>
			</db:select>
			
			<choice>
				<when expression="#[payload.size() > 0]">
					<set-variable variableName="selectedAsset" value="#[payload[0]]" />
					
					<!-- Update asset status and create allocation -->
					<db:update config-ref="PostgreSQL_Database_Config">
						<db:sql><![CDATA[UPDATE assets SET status = 'ALLOCATED', updated_at = CURRENT_TIMESTAMP WHERE id = :assetId]]></db:sql>
						<db:input-parameters><![CDATA[#[{'assetId': vars.selectedAsset.id}]]]></db:input-parameters>
					</db:update>
					
					<db:insert config-ref="PostgreSQL_Database_Config">
						<db:sql><![CDATA[
							INSERT INTO asset_allocations 
							(asset_id, employee_id, allocated_date, allocation_status, allocation_reason, approved_by, approval_date, notes)
							VALUES (:assetId, 
							       (SELECT id FROM employees WHERE employee_id = :employeeId), 
							       CURRENT_DATE, 'ALLOCATED', 'Employee Onboarding', 'MCP System', CURRENT_DATE,
							       'Allocated via Asset Allocation MCP Server')
						]]></db:sql>
						<db:input-parameters><![CDATA[#[{
							'assetId': vars.selectedAsset.id,
							'employeeId': vars.requestPayload.employeeId
						}]]]></db:input-parameters>
					</db:insert>
					
					<!-- Add to allocated assets list -->
					<set-variable variableName="allocatedAssets" value="#[vars.allocatedAssets + [{
						assetId: vars.selectedAsset.id,
						assetTag: vars.selectedAsset.asset_tag,
						assetName: vars.selectedAsset.asset_name,
						category: vars.selectedAsset.category_name,
						brand: vars.selectedAsset.brand,
						model: vars.selectedAsset.model,
						serialNumber: vars.selectedAsset.serial_number,
						condition: vars.selectedAsset.condition_status,
						allocationDate: now() as String {format: 'yyyy-MM-dd'},
						status: 'ALLOCATED'
					}]]" />
				</when>
				<otherwise>
					<logger level="WARN" message="âš ï¸ No available asset of type: #[vars.currentAssetType]" />
				</otherwise>
			</choice>
				</foreach>
			</when>
			<otherwise>
				<logger level="WARN" message="No assets to allocate for employee: #[payload.employeeId]" />
			</otherwise>
		</choice>
		
		<!-- Return success response -->
		<ee:transform doc:name="PostgreSQL Success Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Assets allocated successfully via PostgreSQL",
	database: vars.databaseUsed,
	employeeId: payload.employeeId,
	employeeName: payload.firstName ++ ' ' ++ payload.lastName,
	allocatedAssets: vars.allocatedAssets,
	allocationCount: sizeOf(vars.allocatedAssets),
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: false
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- H2 Asset Allocation -->
	<flow name="allocate-assets-h2" doc:name="H2 Asset Allocation">
		<logger level="INFO" message="ğŸ  Processing allocation via H2 embedded database..." />
		<set-variable variableName="allocatedAssets" value="#[[]]" />
		
		<!-- Initialize H2 database if needed -->
		<try doc:name="Try H2 Initialization">
			<db:select config-ref="H2_Database_Config">
				<db:sql><![CDATA[SELECT COUNT(*) FROM assets]]></db:sql>
			</db:select>
			<error-handler>
				<on-error-continue type="ANY">
					<logger level="INFO" message="Initializing H2 database tables..."/>
					<flow-ref name="create-h2-tables"/>
				</on-error-continue>
			</error-handler>
		</try>
		
		<!-- Allocate each requested asset from H2 database -->
		<foreach collection="#[payload.assets]">
			<set-variable variableName="currentAssetType" value="#[payload]" />
			
			<!-- Find available asset in H2 -->
			<db:select config-ref="H2_Database_Config">
				<db:sql><![CDATA[
					SELECT a.*, ac.category_name 
					FROM assets a 
					JOIN asset_categories ac ON a.category_id = ac.id 
					WHERE UPPER(ac.category_name) = UPPER(:assetType) 
					AND a.status = 'AVAILABLE' 
					ORDER BY a.purchase_date DESC 
					LIMIT 1
				]]></db:sql>
				<db:input-parameters><![CDATA[#[{'assetType': vars.currentAssetType}]]]></db:input-parameters>
			</db:select>
			
			<choice>
				<when expression="#[payload.size() > 0]">
					<set-variable variableName="selectedAsset" value="#[payload[0]]" />
					
					<!-- Update asset status in H2 -->
					<db:update config-ref="H2_Database_Config">
						<db:sql><![CDATA[UPDATE assets SET status = 'ALLOCATED' WHERE id = :assetId]]></db:sql>
						<db:input-parameters><![CDATA[#[{'assetId': vars.selectedAsset.id}]]]></db:input-parameters>
					</db:update>
					
					<!-- Add to allocated assets list -->
					<set-variable variableName="allocatedAssets" value="#[vars.allocatedAssets + [{
						assetId: vars.selectedAsset.id,
						assetTag: vars.selectedAsset.asset_tag,
						assetName: vars.selectedAsset.asset_name,
						category: vars.selectedAsset.category_name,
						brand: vars.selectedAsset.brand,
						model: vars.selectedAsset.model,
						serialNumber: vars.selectedAsset.serial_number,
						condition: vars.selectedAsset.condition_status,
						allocationDate: now() as String {format: 'yyyy-MM-dd'},
						status: 'ALLOCATED'
					}]]" />
					
					<logger level="INFO" message="âœ… H2 asset allocated: #[vars.selectedAsset.asset_tag] to #[payload.employeeId]" />
				</when>
				<otherwise>
					<logger level="WARN" message="âš ï¸ No available H2 assets of type: #[vars.currentAssetType]" />
				</otherwise>
			</choice>
		</foreach>
		
		<!-- Return H2 success response -->
		<ee:transform doc:name="H2 Success Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Assets allocated successfully via H2 embedded database",
	database: vars.databaseUsed,
	employeeId: payload.employeeId,
	employeeName: payload.firstName ++ ' ' ++ payload.lastName,
	allocatedAssets: vars.allocatedAssets,
	allocationCount: sizeOf(vars.allocatedAssets),
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: false
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- Return Asset with Fallback Strategy -->
	<flow name="return-asset-with-fallback" doc:name="Return Asset with Smart Fallback">
		<try doc:name="Database Operation with Fallback">
			<!-- Try Primary Database First -->
			<try doc:name="Primary Database Operation">
				<choice doc:name="Database Strategy">
					<when expression='#["${db.strategy}" == "h2" or "${env}" == "sandbox" or "${env}" == "production"]'>
						<flow-ref name="return-asset-h2"/>
						<set-variable variableName="databaseUsed" value="h2"/>
					</when>
					<otherwise>
						<flow-ref name="return-asset-postgresql"/>
						<set-variable variableName="databaseUsed" value="postgresql"/>
					</otherwise>
				</choice>
				
				<error-handler>
					<on-error-continue type="DB:*" doc:name="Fallback to Alternative DB">
						<logger level="WARN" message="Primary database failed, trying fallback database: #[error.description]"/>
						
						<choice doc:name="Try Fallback Database">
							<when expression='#[vars.databaseUsed != "h2"]'>
								<flow-ref name="return-asset-h2"/>
								<set-variable variableName="databaseUsed" value="h2-fallback"/>
							</when>
							<otherwise>
								<flow-ref name="return-asset-postgresql"/>
								<set-variable variableName="databaseUsed" value="postgresql-fallback"/>
							</otherwise>
						</choice>
					</on-error-continue>
				</error-handler>
			</try>
			
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="return-asset-mock-response"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- PostgreSQL Return Asset -->
	<flow name="return-asset-postgresql" doc:name="PostgreSQL Return Asset">
		<db:update config-ref="PostgreSQL_Database_Config">
			<db:sql><![CDATA[UPDATE assets SET status = 'AVAILABLE', updated_at = CURRENT_TIMESTAMP WHERE asset_tag = :assetTag]]></db:sql>
			<db:input-parameters><![CDATA[#[{'assetTag': payload.assetTag}]]]></db:input-parameters>
		</db:update>
		
		<db:update config-ref="PostgreSQL_Database_Config">
			<db:sql><![CDATA[
				UPDATE asset_allocations 
				SET allocation_status = 'RETURNED', 
				    actual_return_date = CURRENT_DATE,
				    return_condition = :condition,
				    notes = COALESCE(notes, '') || ' | Returned: ' || :returnNotes
				WHERE asset_id = (SELECT id FROM assets WHERE asset_tag = :assetTag)
				AND allocation_status = 'ALLOCATED'
			]]></db:sql>
			<db:input-parameters><![CDATA[#[{
				'assetTag': payload.assetTag,
				'condition': payload.condition default 'GOOD',
				'returnNotes': payload.notes default 'Asset returned via MCP'
			}]]]></db:input-parameters>
		</db:update>
		
		<ee:transform doc:name="PostgreSQL Return Success Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Asset returned successfully via PostgreSQL",
	database: vars.databaseUsed,
	assetTag: payload.assetTag,
	condition: payload.condition default 'GOOD',
	returnDate: now() as String {format: 'yyyy-MM-dd'},
	notes: payload.notes default 'Asset returned successfully',
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: false
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- H2 Return Asset -->
	<flow name="return-asset-h2" doc:name="H2 Return Asset">
		<db:update config-ref="H2_Database_Config">
			<db:sql><![CDATA[UPDATE assets SET status = 'AVAILABLE' WHERE asset_tag = :assetTag]]></db:sql>
			<db:input-parameters><![CDATA[#[{'assetTag': payload.assetTag}]]]></db:input-parameters>
		</db:update>
		
		<ee:transform doc:name="H2 Return Success Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Asset returned successfully via H2 embedded database",
	database: vars.databaseUsed,
	assetTag: payload.assetTag,
	condition: payload.condition default 'GOOD',
	returnDate: now() as String {format: 'yyyy-MM-dd'},
	notes: payload.notes default 'Asset returned successfully',
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: false
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- List Assets with Fallback Strategy -->
	<flow name="list-assets-with-fallback" doc:name="List Assets with Smart Fallback">
		<try doc:name="Database Query with Fallback">
			<!-- Try Primary Database First -->
			<try doc:name="Primary Database Query">
				<choice doc:name="Database Strategy">
					<when expression='#["${db.strategy}" == "h2" or "${env}" == "sandbox" or "${env}" == "production"]'>
						<db:select config-ref="H2_Database_Config">
							<db:sql><![CDATA[
								SELECT a.*, ac.category_name
								FROM assets a 
								JOIN asset_categories ac ON a.category_id = ac.id
								WHERE (:statusFilter = '' OR a.status = :statusFilter)
								AND (:categoryFilter = '' OR UPPER(ac.category_name) = UPPER(:categoryFilter))
								ORDER BY ac.category_name, a.asset_name
							]]></db:sql>
							<db:input-parameters><![CDATA[#[{
								statusFilter: vars.statusFilter,
								categoryFilter: vars.categoryFilter
							}]]]></db:input-parameters>
						</db:select>
						<set-variable variableName="databaseUsed" value="h2"/>
					</when>
					<otherwise>
						<db:select config-ref="PostgreSQL_Database_Config">
							<db:sql><![CDATA[
								SELECT a.*, ac.category_name,
								       CASE WHEN aa.allocation_status = 'ALLOCATED' THEN e.employee_id ELSE NULL END as allocated_to,
								       aa.allocated_date, aa.allocation_status
								FROM assets a 
								JOIN asset_categories ac ON a.category_id = ac.id
								LEFT JOIN asset_allocations aa ON a.id = aa.asset_id AND aa.allocation_status = 'ALLOCATED'
								LEFT JOIN employees e ON aa.employee_id = e.id
								WHERE (:statusFilter = '' OR a.status = :statusFilter)
								AND (:categoryFilter = '' OR UPPER(ac.category_name) = UPPER(:categoryFilter))
								ORDER BY ac.category_name, a.asset_name
							]]></db:sql>
							<db:input-parameters><![CDATA[#[{
								statusFilter: vars.statusFilter,
								categoryFilter: vars.categoryFilter
							}]]]></db:input-parameters>
						</db:select>
						<set-variable variableName="databaseUsed" value="postgresql"/>
					</otherwise>
				</choice>
				
				<error-handler>
					<on-error-continue type="DB:*" doc:name="Fallback to Alternative DB">
						<logger level="WARN" message="Primary database failed, trying fallback: #[error.description]"/>
						<flow-ref name="list-assets-fallback-database"/>
					</on-error-continue>
				</error-handler>
			</try>
			
			<ee:transform doc:name="Format Assets List Response">
				<ee:message>
					<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Assets listed successfully",
	database: vars.databaseUsed,
	assets: payload,
	assetCount: sizeOf(payload),
	statistics: {
		available: sizeOf(payload filter ($.status == 'AVAILABLE')),
		allocated: sizeOf(payload filter ($.status == 'ALLOCATED')),
		categories: payload distinctBy $.category_name pluck $.category_name
	},
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: vars.databaseUsed == "mock"
}]]></ee:set-payload>
				</ee:message>
			</ee:transform>
			
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="list-assets-mock-response"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- Get Available Assets with Fallback Strategy -->
	<flow name="get-available-assets-with-fallback" doc:name="Get Available Assets with Smart Fallback">
		<try doc:name="Database Query with Fallback">
			<!-- Try Primary Database First -->
			<try doc:name="Primary Database Query">
				<choice doc:name="Database Strategy">
					<when expression='#["${db.strategy}" == "h2" or "${env}" == "sandbox" or "${env}" == "production"]'>
						<db:select config-ref="H2_Database_Config">
							<db:sql><![CDATA[
								SELECT a.*, ac.category_name
								FROM assets a 
								JOIN asset_categories ac ON a.category_id = ac.id 
								WHERE a.status = 'AVAILABLE'
								ORDER BY ac.category_name, a.asset_name
							]]></db:sql>
						</db:select>
						<set-variable variableName="databaseUsed" value="h2"/>
					</when>
					<otherwise>
						<db:select config-ref="PostgreSQL_Database_Config">
							<db:sql><![CDATA[
								SELECT a.*, ac.category_name, a.specifications::text as specs_json
								FROM assets a 
								JOIN asset_categories ac ON a.category_id = ac.id 
								WHERE a.status = 'AVAILABLE'
								ORDER BY ac.category_name, a.asset_name
							]]></db:sql>
						</db:select>
						<set-variable variableName="databaseUsed" value="postgresql"/>
					</otherwise>
				</choice>
				
				<error-handler>
					<on-error-continue type="DB:*">
						<logger level="WARN" message="Primary database failed, trying fallback: #[error.description]"/>
						<flow-ref name="get-available-assets-fallback-database"/>
					</on-error-continue>
				</error-handler>
			</try>
			
			<ee:transform doc:name="Format Available Assets Response">
				<ee:message>
					<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Available assets retrieved successfully",
	database: vars.databaseUsed,
	assets: payload,
	assetCount: sizeOf(payload),
	categories: payload distinctBy $.category_name pluck $.category_name,
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: vars.databaseUsed == "mock"
}]]></ee:set-payload>
				</ee:message>
			</ee:transform>
			
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="get-available-assets-mock-response"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- Get Employee Assets with Fallback Strategy -->
	<flow name="get-employee-assets-with-fallback" doc:name="Get Employee Assets with Smart Fallback">
		<try doc:name="Database Query with Fallback">
			<!-- Try Primary Database First -->
			<try doc:name="Primary Database Query">
				<choice doc:name="Database Strategy">
					<when expression='#["${db.strategy}" == "h2" or "${env}" == "sandbox" or "${env}" == "production"]'>
						<db:select config-ref="H2_Database_Config">
							<db:sql><![CDATA[
								SELECT a.*, ac.category_name, aa.allocated_date, aa.allocation_status, aa.notes, aa.id as allocation_id
								FROM asset_allocations aa
								JOIN assets a ON aa.asset_id = a.id
								JOIN asset_categories ac ON a.category_id = ac.id
								JOIN employees e ON aa.employee_id = e.id
								WHERE e.employee_id = :employeeId 
								AND aa.allocation_status = 'ALLOCATED'
								ORDER BY aa.allocated_date DESC
							]]></db:sql>
							<db:input-parameters><![CDATA[#[{'employeeId': vars.employeeId}]]]></db:input-parameters>
						</db:select>
						<set-variable variableName="databaseUsed" value="h2"/>
					</when>
					<otherwise>
						<db:select config-ref="PostgreSQL_Database_Config">
							<db:sql><![CDATA[
								SELECT a.*, ac.category_name, aa.allocated_date, aa.allocation_status, aa.notes, aa.id as allocation_id
								FROM asset_allocations aa
								JOIN assets a ON aa.asset_id = a.id
								JOIN asset_categories ac ON a.category_id = ac.id
								JOIN employees e ON aa.employee_id = e.id
								WHERE e.employee_id = :employeeId 
								AND aa.allocation_status = 'ALLOCATED'
								ORDER BY aa.allocated_date DESC
							]]></db:sql>
							<db:input-parameters><![CDATA[#[{'employeeId': vars.employeeId}]]]></db:input-parameters>
						</db:select>
						<set-variable variableName="databaseUsed" value="postgresql"/>
					</otherwise>
				</choice>
				
				<error-handler>
					<on-error-continue type="DB:*">
						<logger level="WARN" message="Primary database failed, trying fallback: #[error.description]"/>
						<flow-ref name="get-employee-assets-fallback-database"/>
					</on-error-continue>
				</error-handler>
			</try>
			
			<ee:transform doc:name="Format Employee Assets Response">
				<ee:message>
					<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Employee assets retrieved successfully",
	database: vars.databaseUsed,
	employeeId: vars.employeeId,
	assets: payload,
	assetCount: sizeOf(payload),
	categories: payload distinctBy $.category_name pluck $.category_name,
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: vars.databaseUsed == "mock"
}]]></ee:set-payload>
				</ee:message>
			</ee:transform>
			
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="get-employee-assets-mock-response"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- ========================================================================================= -->
	<!-- DATABASE SETUP AND HELPER FLOWS -->
	<!-- ========================================================================================= -->

	<!-- PostgreSQL Database Setup -->
	<flow name="setup-postgresql-database" doc:name="PostgreSQL Database Setup">
		<logger level="INFO" message="Initializing PostgreSQL database..."/>
		
		<try doc:name="PostgreSQL Connection Test">
			<db:select config-ref="PostgreSQL_Database_Config">
				<db:sql><![CDATA[SELECT 1 as test]]></db:sql>
			</db:select>
			
			<logger level="INFO" message="PostgreSQL connection successful"/>
			
			<!-- Create tables if they don't exist -->
			<flow-ref name="create-postgresql-tables"/>
			
			<error-handler>
				<on-error-propagate type="ANY">
					<logger level="ERROR" message="PostgreSQL setup failed: #[error.description]"/>
				</on-error-propagate>
			</error-handler>
		</try>
	</flow>

	<!-- H2 Database Setup -->
	<flow name="setup-h2-database" doc:name="H2 Database Setup">
		<logger level="INFO" message="Initializing H2 database..."/>
		
		<try doc:name="H2 Connection Test">
			<db:select config-ref="H2_Database_Config">
				<db:sql><![CDATA[SELECT 1 as test]]></db:sql>
			</db:select>
			
			<logger level="INFO" message="H2 connection successful"/>
			
			<!-- Create tables if they don't exist -->
			<flow-ref name="create-h2-tables"/>
			
			<error-handler>
				<on-error-propagate type="ANY">
					<logger level="ERROR" message="H2 setup failed: #[error.description]"/>
				</on-error-propagate>
			</error-handler>
		</try>
	</flow>

	<!-- Create PostgreSQL Tables -->
	<flow name="create-postgresql-tables" doc:name="Create PostgreSQL Tables">
		<db:execute-script config-ref="PostgreSQL_Database_Config" file="init.sql" />
		<logger level="INFO" message="PostgreSQL tables created successfully"/>
	</flow>

	<!-- Create H2 Tables -->
	<flow name="create-h2-tables" doc:name="Create H2 Tables">
		<db:execute-script config-ref="H2_Database_Config" file="init-h2.sql" />
		<logger level="INFO" message="H2 tables created successfully"/>
	</flow>

	<!-- ========================================================================================= -->
	<!-- HEALTH CHECK COMPONENTS -->
	<!-- ========================================================================================= -->

	<!-- Database Health Status -->
	<flow name="database-health-status" doc:name="Database Health Check">
		<try doc:name="Test Database Connection">
			<choice doc:name="Test Active Database">
				<when expression='#["${db.strategy}" == "h2"]'>
					<db:select config-ref="H2_Database_Config">
						<db:sql><![CDATA[SELECT COUNT(*) as asset_count FROM assets]]></db:sql>
					</db:select>
					<set-variable variableName="dbType" value="H2"/>
				</when>
				<otherwise>
					<db:select config-ref="PostgreSQL_Database_Config">
						<db:sql><![CDATA[SELECT COUNT(*) as asset_count FROM assets]]></db:sql>
					</db:select>
					<set-variable variableName="dbType" value="PostgreSQL"/>
				</otherwise>
			</choice>
			
			<ee:transform doc:name="Database Health Response">
				<ee:message>
					<ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
	name: "database",
	healthy: true,
	status: "UP",
	details: {
		"type": vars.dbType,
		assetCount: payload[0].asset_count,
		connection: "active"
	}
}]]></ee:set-payload>
				</ee:message>
			</ee:transform>
			
			<error-handler>
				<on-error-continue type="ANY">
					<ee:transform doc:name="Database Error Response">
						<ee:message>
							<ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
	name: "database",
	healthy: false,
	status: "DOWN",
	details: {
		error: error.description,
		"type": "unavailable"
	}
}]]></ee:set-payload>
						</ee:message>
					</ee:transform>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- Application Health Status -->
	<flow name="application-health-status" doc:name="Application Health Check">
		<ee:transform doc:name="Application Health Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
	name: "application",
	healthy: true,
	status: "UP",
	details: {
		version: "${mcp.server.version}",
		environment: "${env}",
		memory: java!java::lang::Runtime::getRuntime().freeMemory(),
		uptime: "running"
	}
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- Configuration Health Status -->
	<flow name="configuration-health-status" doc:name="Configuration Health Check">
		<ee:transform doc:name="Configuration Health Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
	name: "configuration",
	healthy: true,
	status: "UP",
	details: {
		database: "${db.strategy}",
		mockMode: "${mcp.features.mock.enabled}",
		auditEnabled: "${mcp.features.audit.enabled}",
		cacheEnabled: "${cache.enabled}"
	}
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- ========================================================================================= -->
	<!-- FALLBACK DATABASE FLOWS -->
	<!-- ========================================================================================= -->

	<flow name="list-assets-fallback-database" doc:name="List Assets Fallback Database">
		<try doc:name="Try Fallback Database">
			<choice doc:name="Try Fallback Database">
				<when expression='#[vars.databaseUsed != "h2"]'>
					<db:select config-ref="H2_Database_Config">
						<db:sql><![CDATA[
							SELECT a.*, ac.category_name
							FROM assets a 
							JOIN asset_categories ac ON a.category_id = ac.id
							WHERE (:statusFilter = '' OR a.status = :statusFilter)
							AND (:categoryFilter = '' OR UPPER(ac.category_name) = UPPER(:categoryFilter))
							ORDER BY ac.category_name, a.asset_name
						]]></db:sql>
						<db:input-parameters><![CDATA[#[{
							statusFilter: vars.statusFilter,
							categoryFilter: vars.categoryFilter
						}]]]></db:input-parameters>
					</db:select>
					<set-variable variableName="databaseUsed" value="h2-fallback"/>
				</when>
				<otherwise>
					<db:select config-ref="PostgreSQL_Database_Config">
						<db:sql><![CDATA[
							SELECT a.*, ac.category_name,
							       CASE WHEN aa.allocation_status = 'ALLOCATED' THEN e.employee_id ELSE NULL END as allocated_to
							FROM assets a 
							JOIN asset_categories ac ON a.category_id = ac.id
							LEFT JOIN asset_allocations aa ON a.id = aa.asset_id AND aa.allocation_status = 'ALLOCATED'
							LEFT JOIN employees e ON aa.employee_id = e.id
							WHERE (:statusFilter = '' OR a.status = :statusFilter)
							AND (:categoryFilter = '' OR UPPER(ac.category_name) = UPPER(:categoryFilter))
							ORDER BY ac.category_name, a.asset_name
						]]></db:sql>
						<db:input-parameters><![CDATA[#[{
							statusFilter: vars.statusFilter,
							categoryFilter: vars.categoryFilter
						}]]]></db:input-parameters>
					</db:select>
					<set-variable variableName="databaseUsed" value="postgresql-fallback"/>
				</otherwise>
			</choice>
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="list-assets-mock-response"/>
					<set-variable variableName="databaseUsed" value="mock"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<flow name="get-available-assets-fallback-database" doc:name="Get Available Assets Fallback Database">
		<try doc:name="Try Fallback Database">
			<choice doc:name="Try Fallback Database">
				<when expression='#[vars.databaseUsed != "h2"]'>
					<db:select config-ref="H2_Database_Config">
						<db:sql><![CDATA[
							SELECT a.*, ac.category_name
							FROM assets a 
							JOIN asset_categories ac ON a.category_id = ac.id 
							WHERE a.status = 'AVAILABLE'
							ORDER BY ac.category_name, a.asset_name
						]]></db:sql>
					</db:select>
					<set-variable variableName="databaseUsed" value="h2-fallback"/>
				</when>
				<otherwise>
					<db:select config-ref="PostgreSQL_Database_Config">
						<db:sql><![CDATA[
							SELECT a.*, ac.category_name
							FROM assets a 
							JOIN asset_categories ac ON a.category_id = ac.id 
							WHERE a.status = 'AVAILABLE'
							ORDER BY ac.category_name, a.asset_name
						]]></db:sql>
					</db:select>
					<set-variable variableName="databaseUsed" value="postgresql-fallback"/>
				</otherwise>
			</choice>
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="get-available-assets-mock-response"/>
					<set-variable variableName="databaseUsed" value="mock"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<flow name="get-employee-assets-fallback-database" doc:name="Get Employee Assets Fallback Database">
		<try doc:name="Try Fallback Database">
			<choice doc:name="Try Fallback Database">
				<when expression='#[vars.databaseUsed != "h2"]'>
					<db:select config-ref="H2_Database_Config">
						<db:sql><![CDATA[
							SELECT a.*, ac.category_name, aa.allocated_date, aa.allocation_status
							FROM asset_allocations aa
							JOIN assets a ON aa.asset_id = a.id
							JOIN asset_categories ac ON a.category_id = ac.id
							JOIN employees e ON aa.employee_id = e.id
							WHERE e.employee_id = :employeeId 
							AND aa.allocation_status = 'ALLOCATED'
							ORDER BY aa.allocated_date DESC
						]]></db:sql>
						<db:input-parameters><![CDATA[#[{'employeeId': vars.employeeId}]]]></db:input-parameters>
					</db:select>
					<set-variable variableName="databaseUsed" value="h2-fallback"/>
				</when>
				<otherwise>
					<db:select config-ref="PostgreSQL_Database_Config">
						<db:sql><![CDATA[
							SELECT a.*, ac.category_name, aa.allocated_date, aa.allocation_status, aa.notes
							FROM asset_allocations aa
							JOIN assets a ON aa.asset_id = a.id
							JOIN asset_categories ac ON a.category_id = ac.id
							JOIN employees e ON aa.employee_id = e.id
							WHERE e.employee_id = :employeeId 
							AND aa.allocation_status = 'ALLOCATED'
							ORDER BY aa.allocated_date DESC
						]]></db:sql>
						<db:input-parameters><![CDATA[#[{'employeeId': vars.employeeId}]]]></db:input-parameters>
					</db:select>
					<set-variable variableName="databaseUsed" value="postgresql-fallback"/>
				</otherwise>
			</choice>
			<error-handler>
				<on-error-continue type="ANY">
					<flow-ref name="get-employee-assets-mock-response"/>
					<set-variable variableName="databaseUsed" value="mock"/>
				</on-error-continue>
			</error-handler>
		</try>
	</flow>

	<!-- ========================================================================================= -->
	<!-- MOCK RESPONSE FLOWS FOR FALLBACK -->
	<!-- ========================================================================================= -->

	<!-- Allocate Assets Mock Response -->
	<flow name="allocate-assets-mock-response" doc:name="Allocate Assets Mock Response">
		<logger level="WARN" message="Using mock mode for asset allocation - ID: #[payload.employeeId default 'unknown']"/>
		
		<ee:transform doc:name="Mock Allocate Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Assets allocated successfully (mock mode)",
	database: "mock",
	employeeId: payload.employeeId default "EMP001",
	employeeName: (payload.firstName default "Mock") ++ " " ++ (payload.lastName default "Employee"),
	allocatedAssets: [
		{
			assetId: "MOCK-001",
			assetTag: "MOCK-LAP-001",
			assetName: "Mock Laptop Dell Latitude",
			category: "LAPTOP",
			brand: "Dell",
			model: "Latitude Demo",
			serialNumber: "MOCK-SERIAL-001",
			condition: "NEW",
			allocationDate: now() as String {format: 'yyyy-MM-dd'},
			status: "ALLOCATED"
		},
		{
			assetId: "MOCK-002",
			assetTag: "MOCK-ID-001",
			assetName: "Mock ID Card",
			category: "ID_CARD",
			brand: "HID Global",
			model: "ProxCard Demo",
			serialNumber: "MOCK-SERIAL-002",
			condition: "NEW",
			allocationDate: now() as String {format: 'yyyy-MM-dd'},
			status: "ALLOCATED"
		}
	],
	allocationCount: 2,
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: true,
	warning: "This is a mock response - no actual database operation was performed"
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- Return Asset Mock Response -->
	<flow name="return-asset-mock-response" doc:name="Return Asset Mock Response">
		<logger level="WARN" message="Using mock mode for asset return - Asset: #[payload.assetTag default 'unknown']"/>
		
		<ee:transform doc:name="Mock Return Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Asset returned successfully (mock mode)",
	database: "mock",
	assetTag: payload.assetTag default "MOCK-LAP-001",
	condition: payload.condition default 'GOOD',
	returnDate: now() as String {format: 'yyyy-MM-dd'},
	notes: payload.notes default 'Asset returned successfully via mock mode',
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: true,
	warning: "This is a mock response - no actual database operation was performed"
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- List Assets Mock Response -->
	<flow name="list-assets-mock-response" doc:name="List Assets Mock Response">
		<logger level="WARN" message="Using mock mode for list assets"/>
		
		<ee:transform doc:name="Mock List Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Assets listed successfully (mock mode)",
	database: "mock",
	assets: [
		{
			id: 1,
			asset_tag: "MOCK-LAP-001",
			asset_name: "Mock Dell Latitude Laptop",
			category_name: "LAPTOP",
			brand: "Dell",
			model: "Latitude 5520",
			status: "AVAILABLE",
			allocated_to: null
		},
		{
			id: 2,
			asset_tag: "MOCK-LAP-002",
			asset_name: "Mock MacBook Pro",
			category_name: "LAPTOP", 
			brand: "Apple",
			model: "MacBook Pro 16-inch",
			status: "ALLOCATED",
			allocated_to: "EMP001"
		},
		{
			id: 3,
			asset_tag: "MOCK-ID-001",
			asset_name: "Mock ID Card",
			category_name: "ID_CARD",
			brand: "HID Global",
			model: "ProxCard II",
			status: "AVAILABLE",
			allocated_to: null
		}
	],
	assetCount: 3,
	statistics: {
		available: 2,
		allocated: 1,
		categories: ["LAPTOP", "ID_CARD"]
	},
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: true,
	warning: "This is mock data - not from actual database"
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- Get Available Assets Mock Response -->
	<flow name="get-available-assets-mock-response" doc:name="Get Available Assets Mock Response">
		<logger level="WARN" message="Using mock mode for get available assets"/>
		
		<ee:transform doc:name="Mock Available Assets Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Available assets retrieved successfully (mock mode)",
	database: "mock",
	assets: [
		{
			id: 1,
			asset_tag: "MOCK-LAP-001",
			asset_name: "Mock Dell Latitude Laptop",
			category_name: "LAPTOP",
			brand: "Dell",
			model: "Latitude 5520",
			status: "AVAILABLE"
		},
		{
			id: 3,
			asset_tag: "MOCK-ID-001",
			asset_name: "Mock ID Card",
			category_name: "ID_CARD",
			brand: "HID Global",
			model: "ProxCard II",
			status: "AVAILABLE"
		}
	],
	assetCount: 2,
	categories: ["LAPTOP", "ID_CARD"],
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: true,
	warning: "This is mock data - not from actual database"
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

	<!-- Get Employee Assets Mock Response -->
	<flow name="get-employee-assets-mock-response" doc:name="Get Employee Assets Mock Response">
		<logger level="WARN" message="Using mock mode for get employee assets - ID: #[vars.employeeId]"/>
		
		<ee:transform doc:name="Mock Employee Assets Response">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
	success: true,
	message: "Employee assets retrieved successfully (mock mode)",
	database: "mock",
	employeeId: vars.employeeId default "EMP001",
	assets: [
		{
			asset_tag: "MOCK-LAP-002",
			asset_name: "Mock MacBook Pro",
			category_name: "LAPTOP",
			brand: "Apple",
			model: "MacBook Pro 16-inch",
			allocated_date: "2024-01-15",
			allocation_status: "ALLOCATED"
		}
	],
	assetCount: 1,
	categories: ["LAPTOP"],
	timestamp: now() as String {format: 'yyyy-MM-dd HH:mm:ss'},
	mockMode: true,
	warning: "This is mock data - not from actual database"
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>
	</flow>

</mule>
